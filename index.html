<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ideOS+</title>
<link rel="apple-touch-icon" href="icon.png">
<script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
<style>
:root {
    --accent: #4caf50;
    --ai-purple: #bb86fc;
    --save-blue: #00bcd4;
    --clear-red: #ff5252;
}

body {
    margin: 0;
    background: #0b0b0b;
    font-family: 'SF Mono', monospace;
    display: flex;
    height: 100vh;
    color: #fff;
    overflow: hidden;
}

#left-panel {
    width: 50%;
    display: flex;
    flex-direction: column;
    border-right: 1px solid #222;
    position: relative;
}

#right-panel {
    width: 50%;
    background: #000;
    position: relative;
}

#tabs {
    background: #111;
    display: flex;
    padding: 10px;
    gap: 8px;
    border-bottom: 1px solid #222;
    align-items: center;
    overflow-x: auto;
    white-space: nowrap;
    scrollbar-width: thin;
}

.tab {
    color: #666;
    font-size: 11px;
    cursor: pointer;
    padding: 6px 10px;
    border: 1px solid transparent;
    text-transform: uppercase;
}

.tab.active {
    color: var(--accent);
    border: 1px solid var(--accent);
}

#project-name {
    background: #000;
    border: 1px solid #333;
    color: var(--save-blue);
    font-size: 11px;
    padding: 5px;
    outline: none;
    width: 120px;
}

#editor {
    flex: 1;
    background: #0b0b0b;
    color: #d4d4d4;
    border: none;
    padding: 20px;
    font-size: 16px;
    outline: none;
    resize: none;
    line-height: 1.5;
    tab-size: 4;
    white-space: pre;
}

/* error highlighting */
#editor.error {
    border: 1px solid #ff4444;
    box-shadow: 0 0 8px #ff4444;
}

#preview {
    width: 100%;
    height: 100%;
    border: none;
    background: #fff;
}

.overlay {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    padding: 25px;
    box-sizing: border-box;
    z-index: 5;
    overflow-y: auto;
}

.controls {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 1000;
    display: flex;
    gap: 8px;
    align-items: center;
}

#status-light {
    width: 10px;
    height: 10px;
    background: var(--clear-red);
    border-radius: 50%;
    box-shadow: 0 0 5px var(--clear-red);
}

button {
    background: rgba(0,0,0,0.8);
    border: 1px solid var(--accent);
    color: var(--accent);
    padding: 8px 12px;
    cursor: pointer;
    font-size: 10px;
    font-weight: bold;
    text-transform: uppercase;
}

#library-panel {
    display: none;
    position: absolute;
    left: 0;
    top: 45px;
    width: 220px;
    height: calc(100% - 45px);
    background: #111;
    border-right: 1px solid var(--accent);
    z-index: 2000;
    padding: 15px;
}

.snippet-btn {
    width: 100%;
    margin-bottom: 10px;
    text-align: left;
    border-color: #333;
    color: #aaa;
}

#l-in {
    background: none;
    border: none;
    color: #fff;
    outline: none;
    width: 80%;
    font-family: monospace;
    font-size: 16px;
}

/* cosmic autocomplete bubble */
#autocomplete-box {
    position: absolute;
    background: rgba(0, 255, 0, 0.12);
    border: 1px solid #00ff88;
    color: #00ff88;
    padding: 6px 10px;
    font-size: 12px;
    font-family: monospace;
    border-radius: 6px;
    pointer-events: none;
    backdrop-filter: blur(4px);
    box-shadow: 0 0 12px #00ff88;
    display: none;
    z-index: 9999;
}
</style>
</head>
<body>

<div id="left-panel">
    <div id="tabs">
        <button onclick="toggleLib()" style="border-color:#888; color:#888;">LIB</button>
        <input type="text" id="project-name" value="my_project" title="Enter filename here">

        <div id="html-tab" class="tab active" onclick="setMode('HTML')">HTML</div>
        <div id="python-tab" class="tab" onclick="setMode('Python')">Python</div>
        <div id="cpp-tab" class="tab" onclick="setMode('Cpp')">C++</div>
        <div id="linux-tab" class="tab" onclick="setMode('Linux')">Linux</div>
        <div id="swift-tab" class="tab" onclick="setMode('Swift')">Swift</div>
        <div id="rust-tab" class="tab" onclick="setMode('Rust')">Rust</div>
        <div id="java-tab" class="tab" onclick="setMode('Java')">Java</div>

        <button onclick="clearCanvas()" style="border-color:var(--clear-red); color:var(--clear-red); margin-left:auto;">CLEAR</button>
    </div>

    <div id="library-panel">
        <div style="color:var(--accent); margin-bottom:15px; font-size:12px;">PROJECT SNIPPETS</div>
        <button class="snippet-btn" onclick="inject('HTML_BTN')">Neon Button (HTML)</button>
        <button class="snippet-btn" onclick="inject('JS_BOUNCE')">Physics Loop (JS)</button>
        <button class="snippet-btn" onclick="inject('PY_SERVER')">Server Command (PY)</button>
        <button class="snippet-btn" onclick="inject('RUST_HELLO')">Hello World (Rust)</button>
        <button class="snippet-btn" onclick="inject('JAVA_HELLO')">Hello World (Java)</button>
    </div>

    <textarea id="editor" spellcheck="true" placeholder=""></textarea>
    <div id="autocomplete-box"></div>
</div>

<div id="right-panel">
    <div class="controls">
        <div id="status-light"></div>
        <button style="border-color:var(--ai-purple); color:var(--ai-purple);" onclick="runAI()">AI ASSIST</button>
        <button style="border-color:var(--save-blue); color:var(--save-blue);" onclick="save()">SAVE</button>
        <button onclick="run()">RUN</button>
    </div>

    <iframe id="preview"></iframe>

    <div id="linux-term" class="overlay">
        <div id="l-history">Limitless OS v3.8<br></div>
        <br>
        <span style="color:var(--accent)">root@system:~#</span>
        <input type="text" id="l-in" autofocus>
    </div>

    <div id="log-view" class="overlay" onclick="this.style.display='none'"></div>
</div>

<script>
let mode = 'HTML';
let pyodide;

async function init() {
    pyodide = await loadPyodide();
}
init();

function setMode(m) {
    mode = m;
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.getElementById(m.toLowerCase() + '-tab').classList.add('active');
    document.querySelectorAll('.overlay').forEach(o => o.style.display = 'none');
    if (m === 'Linux') document.getElementById('linux-term').style.display = 'block';
    checkErrors(); // re-check errors when mode changes
}

function clearCanvas() {
    if (confirm("Wipe the editor?"))
        document.getElementById('editor').value = "";
    checkErrors();
}

function toggleLib() {
    const lp = document.getElementById('library-panel');
    lp.style.display = lp.style.display === 'block' ? 'none' : 'block';
}

function inject(type) {
    const ed = document.getElementById('editor');
    const snip = {
        'HTML_BTN': '<button style="background:#000; color:#4caf50; border:2px solid #4caf50; padding:15px;">ACTIVE</button>',
        'JS_BOUNCE': '// Animation Logic\nfunction animate() {\n console.log("running...");\n requestAnimationFrame(animate);\n}',
        'PY_SERVER': 'python3 -m http.server 8000',
        'RUST_HELLO': 'fn main() {\n    println!("Hello from Rust!");\n}',
        'JAVA_HELLO': 'public class Main {\n  public static void main(String[] args) {\n    System.out.println("Hello from Java!");\n  }\n}'
    };
    ed.value += "\n" + (snip[type] || '');
    checkErrors();
    toggleLib();
}

async function run() {
    const code = document.getElementById('editor').value;
    const pre = document.getElementById('preview').contentWindow.document;

    if (mode === 'HTML') {
        pre.open();
        pre.write(code);
        pre.close();
    }

    else if (mode === 'Python') {
        pre.open();
        pre.write(`<body style="background:#000;color:#4caf50;padding:20px;font-family:monospace;"><pre id="o"></pre></body>`);
        try {
            pyodide.runPython(`import sys, io; sys.stdout = io.StringIO()`);
            await pyodide.runPythonAsync(code);
            pre.getElementById('o').innerText = pyodide.runPython("sys.stdout.getvalue()");
        } catch(e) {
            pre.getElementById('o').innerText = e;
        }
        pre.close();
    }

    else if (mode === 'Rust') {
        pre.open();
        pre.write(`
            <body style="background:#000;color:#ff9800;padding:20px;font-family:monospace;">
                <pre>Rust mode active. Compilation not supported in-browser.</pre>
            </body>
        `);
        pre.close();
    }

    else if (mode === 'Java') {
        pre.open();
        pre.write(`
            <body style="background:#000;color:#4caf50;padding:20px;font-family:monospace;">
                <pre>Java mode active. Compilation not supported in-browser.</pre>
            </body>
        `);
        pre.close();
    }
}

function runAI() {
    const code = document.getElementById('editor').value;
    const log = document.getElementById('log-view');
    log.style.display = 'block';

    let advice = "No errors found. Logic is clean.";
    if (mode === 'Python' && code.includes('def') && !code.includes(':'))
        advice = "AI Error: Missing colon (:) in function.";

    log.innerHTML = `<div style="color:var(--ai-purple)">[AI ADVISOR]</div><br>> ${advice}`;
}

function save() {
    const name = document.getElementById('project-name').value;
    const ext = mode === 'Python' ? '.py'
              : mode === 'HTML' ? '.html'
              : mode === 'Swift' ? '.swift'
              : mode === 'Cpp' ? '.cpp'
              : mode === 'Rust' ? '.rs'
              : mode === 'Java' ? '.java'
              : '.txt';

    const blob = new Blob([document.getElementById('editor').value], {type: 'text/plain'});
    const a = document.createElement('a');
    a.download = name + ext;
    a.href = window.URL.createObjectURL(blob);
    a.click();
}

const lIn = document.getElementById('l-in');
const lHist = document.getElementById('l-history');

lIn.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        const cmd = lIn.value;
        lHist.innerHTML += `<div><span style="color:var(--accent)">root@system:~#</span> ${cmd}</div>`;

        if (cmd.includes('python3 -m http.server')) {
            document.getElementById('status-light').style.background = '#4caf50';
            document.getElementById('status-light').style.boxShadow = '0 0 10px #4caf50';
            lHist.innerHTML += "<div>[NETWORK] Server is now LIVE.</div>";
        }

        lIn.value = "";
    }
});

// ===============================
// COSMIC EDITOR ENGINE
// ===============================

const editor = document.getElementById("editor");
const acBox = document.getElementById("autocomplete-box");

const acSuggestions = {
    Python: ["print()", "def ", "class ", "import ", "return ", "range()", "len()", "if ", "elif ", "else:", "for ", "while "],
    HTML: ["<div>", "<span>", "<script>", "<style>", "<img>", "<p>", "<a>", "<ul>", "<li>", "<header>", "<footer>"],
    Cpp: ["int ", "std::cout << ;", "std::string ", "return ", "class ", "for ", "while ", "if ", "else "],
    Rust: ["fn ", "let ", "println!()", "match ", "struct ", "impl ", "use "],
    Java: ["public ", "class ", "static ", "void ", "System.out.println()", "if ", "else ", "for ", "while "],
    Swift: ["func ", "let ", "var ", "import ", "print()", "if ", "else ", "for ", "while "],
    Linux: ["ls", "cd", "mkdir", "rm", "touch", "cat", "echo"]
};

let acMatches = [];
let acIndex = 0;

function getCaretCoordinates() {
    const rect = editor.getBoundingClientRect();
    const start = editor.selectionStart;

    const text = editor.value.substring(0, start);
    const span = document.createElement("span");
    span.style.visibility = "hidden";
    span.style.whiteSpace = "pre-wrap";
    span.style.font = window.getComputedStyle(editor).font;
    span.textContent = text.replace(/\n/g, "\n");
    document.body.appendChild(span);

    const coords = span.getBoundingClientRect();
    document.body.removeChild(span);

    return {
        x: coords.left - rect.left,
        y: coords.top - rect.top
    };
}

function showAutocomplete(suggestion) {
    const pos = getCaretCoordinates();
    acBox.style.left = pos.x + "px";
    acBox.style.top = (pos.y + 20) + "px";
    acBox.textContent = suggestion;
    acBox.style.display = "block";
}

function hideAutocomplete() {
    acBox.style.display = "none";
    acMatches = [];
    acIndex = 0;
}

function checkErrors() {
    const text = editor.value;
    let error = false;

    // bracket/brace/paren balance
    const stack = [];
    const pairs = { ")": "(", "]": "[", "}": "{" };
    for (let ch of text) {
        if (ch === "(" || ch === "[" || ch === "{") stack.push(ch);
        if (ch === ")" || ch === "]" || ch === "}") {
            if (stack.pop() !== pairs[ch]) {
                error = true;
                break;
            }
        }
    }
    if (!error && stack.length > 0) {
        error = true;
    }

    // HTML tag balance
    if (!error && mode === "HTML") {
        const tagStack = [];
        const tagRegex = /<\/?([a-zA-Z0-9]+)[^>]*>/g;
        let m;
        while ((m = tagRegex.exec(text)) !== null) {
            const full = m[0];
            const name = m[1];
            if (full.startsWith("</")) {
                if (tagStack.pop() !== name) {
                    error = true;
                    break;
                }
            } else if (!full.endsWith("/>")) {
                tagStack.push(name);
            }
        }
        if (!error && tagStack.length > 0) {
            error = true;
        }
    }

    if (error) {
        editor.classList.add("error");
    } else {
        editor.classList.remove("error");
    }
}

function autoCloseHtmlTag() {
    const cursor = editor.selectionStart;
    const text = editor.value;
    const before = text.substring(0, cursor);
    const match = before.match(/<([a-zA-Z0-9]+)[^>]*>$/);
    if (!match) return;

    const tag = match[1];
    if (before.endsWith("/>") || tag.startsWith("!")) return;

    const insert = `</${tag}>`;
    const after = text.substring(cursor);
    editor.value = before + insert + after;
    editor.selectionStart = editor.selectionEnd = cursor;
}

editor.addEventListener("input", () => {
    const text = editor.value;
    const cursorPos = editor.selectionStart;

    const before = text.substring(0, cursorPos);
    const match = before.match(/[\w<>!]+$/);
    if (!match) {
        hideAutocomplete();
        checkErrors();
        return;
    }

    const currentWord = match[0];
    const list = acSuggestions[mode] || [];

    acMatches = list.filter(s => s.startsWith(currentWord));
    acIndex = 0;

    if (acMatches.length === 0) {
        hideAutocomplete();
    } else {
        showAutocomplete(acMatches[0]);
    }

    checkErrors();
});

editor.addEventListener("keydown", (e) => {
    // Tab / Shift+Tab: cycle suggestions
    if (e.key === "Tab" && acBox.style.display === "block") {
        e.preventDefault();

        if (e.shiftKey) {
            acIndex = (acIndex - 1 + acMatches.length) % acMatches.length;
            showAutocomplete(acMatches[acIndex]);
            return;
        }

        if (acMatches.length > 1) {
            acIndex = (acIndex + 1) % acMatches.length;
            showAutocomplete(acMatches[acIndex]);
            return;
        }
    }

    // Enter: accept suggestion
    if (e.key === "Enter" && acBox.style.display === "block") {
        e.preventDefault();

        const suggestion = acMatches[acIndex];
        const cursorPos = editor.selectionStart;
        const text = editor.value;

        const before = text.substring(0, cursorPos);
        const after = text.substring(cursorPos);

        const match = before.match(/[\w<>!]+$/);
        if (!match) return;

        const start = match.index;
        const newText = before.substring(0, start) + suggestion + after;

        editor.value = newText;

        const parenIndex = suggestion.indexOf("(");
        if (parenIndex !== -1 && suggestion.endsWith(")")) {
            editor.selectionStart = editor.selectionEnd = start + parenIndex + 1;
        } else {
            editor.selectionStart = editor.selectionEnd = start + suggestion.length;
        }

        hideAutocomplete();
        checkErrors();
        return;
    }

    // Auto-indent when no autocomplete bubble
    if (e.key === "Enter" && acBox.style.display !== "block") {
        e.preventDefault();

        const cursorPos = editor.selectionStart;
        const text = editor.value;

        const before = text.substring(0, cursorPos);
        const after = text.substring(cursorPos);

        const lineStart = before.lastIndexOf("\n") + 1;
        const currentLine = before.substring(lineStart);
        const indentMatch = currentLine.match(/^\s*/);
        let indent = indentMatch ? indentMatch[0] : "";

        const trimmed = currentLine.trimEnd();
        if (/[{:]$/.test(trimmed)) {
            indent += "    ";
        }

        const insert = "\n" + indent;
        editor.value = before + insert + after;
        editor.selectionStart = editor.selectionEnd = cursorPos + insert.length;

        checkErrors();
        return;
    }

    // HTML tag auto-closing on ">"
    if (e.key === ">" && mode === "HTML") {
        setTimeout(autoCloseHtmlTag, 0);
    }
});
</script>
</body>
</html>
